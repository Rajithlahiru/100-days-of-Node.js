# Relationships between Objects/ Documents

## Using References (Normalization)

- In order to decide what method to used whe creatinf relationships between objects, a tradeoff between `query performance` vs `consistency` must be performed.

- Provides `data consistency`
- Ex: 
```javascript
    let author = { name: 'myName' };
    let course = { author: 'newAuthor' };
```

## Using Embedded Documents (References)

- Provides `performance`
- Ex: 
```javascript
    let course = { author: { name: 'myName' } };
```

## Hybrid Approach

```javascript
    let author = { name: 'myName' };
    let course = { author: { name: 'myName' } };
```

## Referencing a Document

- When referencing to a certain document, the type of the reference item must be `mongoose.Schema.Types.ObjectId`.

Ex: Referencing the Course document `author` attribute to the name in `Author` document.

```javascript
const Course = mongoose.model('courses', new mongoose.Schema({
    name: String,
    author: {
        type: mongoose.Schema.types.ObjectId, 
        ref: 'Authors'
    }
}));
```

#### `populate` method

- Required when viewing an referenced object

```javascript
    async function listCourses() { 
    const courses = await Course
        .find()
        .populate('author', 'name -_id') // Populates the data from the relevent ObjectID. Here the -_id excludes showing the id field at the output
        .select('name');
    console.log(courses);
    }

```

<hr>

## Embedding a Document

```javascript
    const Course = mongoose.model('Course', new mongoose.Schema({
    name: String,
    // The required document that is to be embedded is placed as shown below
    author: {
        type: authorSchema,
        required: true
    }
    }));
```

#### Passing an array of embedded documents

```javascript
    const course = mongoose.model('Courses', new mongoose.Schema({
        name: String,
        author: [authorSchema]
    }));
```
> When adding, removing a new author item to the same document it's required to define a new author.  
```javascript
    async function addAuthor(courseID, author){
        const course = Courses.findById(courseID);
        course.author.push(author);
        course.save();
    }
    addAuthor('123', new Author({name: 'John Doe'}));
```

## Transactions 

- Ensures the data transaction takes place without any error. 
- If an action failed, the data will be rolled back.
- Else it will complete the data transfer.
- See more: `mongodb two phase commits`
- npm package `fawn` gives the ability to perform a two phase commit.

```javascript
    try{
        new Fawn.task()
            .save('document_name', functionName)
            .update(/*Update query*/)
            .run()
    }
    catch(ex){
        res.status(500).send('Internal Server Error');
    }

```

## Object IDs

- It's genereted by the driver

`_id: 639d7c3d4cf6581150a25219`  

- 12 bytes
- First 4 bytes: timestamp
- Next 3 bytes: machine identifier
- Next 2 bytes: processor ID
- Last 3 bytes: counter

```javascript
const id = mongoose.Types.ObjectId();
// From the below method the time can be extracted
console.log(id.getTimeStamp());

//From the below method the object id can be validated
const validate_id = mongoose.Types.ObjectId.isValid('639d7c3d4cf6581150a25219');
console.log(validate_id);
```
